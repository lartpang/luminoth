import sonnet as snt
import tensorflow as tf
from luminoth.utils.bbox_transform_tf import change_order, clip_boxes, decode


class RCNNProposal(snt.AbstractModule):
    """Create final object detection proposals.
    获得所有框的所有类别的预测结果, 经过边界裁剪, 坐标合理性限定, 预测概率限定, NMS处理后的结
    果的概率中, 前k个最大的预测结果: 概率, 原始坐标, 类别标签

    RCNNProposals takes the proposals generated by the RPN and the predictions
    of the RCNN (both classification and boundin box adjusting) and generates
    a list of object proposals with assigned class.
    该类利用RPN生成的提案, 以及RCNN生成的分类和边界框调整的预测, 并且生成一个指定类别的目标提
    案列表

    In the process it tries to remove duplicated suggestions by applying non
    maximum suppresion (NMS).
    这里主要完成了去冗余, 应用NMS的操作

    We apply NMS because the way object detectors are usually scored is by
    treating duplicated detections (multiple detections that overlap the same
    ground truth value) as false positive. It is resonable to assume that there
    may exist such case that applying NMS is completly unnecesary.
    我们应用NMS是因为对象检测器得分判定通常的方式是把重复检测（多个检测重叠相同基本事实价值）作
    为误报. 可能应用NMS是完全不必要的, 这样的假设也可能存在的.

    Besides applying NMS it also filters the top N results, both for classes
    and in general. These values are easily modifiable in the configuration
    files.
    对于每一类, 除了应用NMS外, 也可过滤前N个结果. 这些值都在配置文件中, 可以修改.
    """

    def __init__(self, num_classes, config, variances=None,
                 name='rcnn_proposal'):
        """
        Args:
            num_classes: Total number of classes RCNN is classifying.
            config: Configuration object.
        """
        super(RCNNProposal, self).__init__(name=name)
        self._num_classes = num_classes
        self._variances = variances

        # Max number of object detections per class.
        self._class_max_detections = config.class_max_detections
        # NMS intersection over union threshold to be used for classes.
        self._class_nms_threshold = float(config.class_nms_threshold)
        # Maximum number of detections to return.
        self._total_max_detections = config.total_max_detections
        # Threshold probability
        self._min_prob_threshold = config.min_prob_threshold or 0.0

    def _build(self, proposals, bbox_pred, cls_prob, im_shape):
        """
        Args:
            这个是RPN的输出
            proposals: Tensor with the RPN proposals bounding boxes.
                Shape (num_proposals, 4). Where num_proposals is less than
                POST_NMS_TOP_N (We don't know exactly beforehand)
                RPN边界框数据
            这两个是RCNN的输出
            bbox_pred: Tensor with the RCNN delta predictions for each proposal
                for each class. Shape (num_proposals, 4 * num_classes)
                RCNN针对每个(上面的RPN的)提案框在每个类别下的预测偏移量和缩放量
            cls_prob: A softmax probability for each proposal where the idx = 0
                is the background class (which we should ignore).
                Shape (num_proposals, num_classes + 1)
                对于每个边界框针对各个类别的softmax概率

        Returns:
            objects:
                Shape (final_num_proposals, 4)
                Where final_num_proposals is unknown before-hand (it depends on
                NMS). The 4-length Tensor for each corresponds to:
                (x_min, y_min, x_max, y_max).
                最终保留下来的边界框的坐标集合
            objects_label:
                Shape (final_num_proposals,)
            objects_label_prob:
                Shape (final_num_proposals,)
        """
        selected_boxes = []
        selected_probs = []
        selected_labels = []

        # For each class, take the proposals with the class-specific
        # predictions (class scores and bbox regression) and filter accordingly
        # (valid area, min probability score and NMS).
        # 对每个类别, 取其类特定预测的提案(类得分和边界框偏移缩放), 并根据合法区域, 最小概率
        # 得分, NMS来进行过滤
        # 对于class_id对应的类别进行如下的操作:
        # ...
        for class_id in range(self._num_classes):
            # Apply the class-specific transformations to the proposals to
            # obtain the current class' prediction.
            # 应用特定类别的转化到提案上, 来获取当前类别的预测
            # 获取该类别下所有提案的类别预测结果, 以及边界框预测结果
            class_prob = cls_prob[:, class_id + 1]  # 0 is background class.
            class_bboxes = bbox_pred[:, (4 * class_id):(4 * class_id + 4)]
            # 针对该类, 从RCNN预测的偏移量(class_bboxes)和RPN输出的参考值(proposals)得
            # 到的预测的左上角和右下角坐标, 获得RCNN的预测的框的真实坐标
            raw_class_objects = decode(
                proposals,  # (num_proposals, 4)
                class_bboxes,  # (num_proposals, 4)
                variances=self._variances,
            )

            # Clip bboxes so they don't go out of the image.
            # 对超出图像的边界框部分进行裁剪, 得到属于图像内部的边界框
            # (num_proposals, 4)
            class_objects = clip_boxes(raw_class_objects, im_shape)

            # Filter objects based on the min probability threshold and on them
            # having a valid area.
            # 对于该类别预测概率大于等于阈值的数据进行筛选
            prob_filter = tf.greater_equal(
                class_prob, self._min_prob_threshold
            )

            (x_min, y_min, x_max, y_max) = tf.unstack(class_objects, axis=1)
            # 要确保,x_max - x_min, y_max - y_min同号, 也就是保证计算面积为正
            area_filter = tf.greater(
                tf.maximum(x_max - x_min, 0.0)
                * tf.maximum(y_max - y_min, 0.0),
                0.0
            )

            # 上面两条判定都要满足
            object_filter = tf.logical_and(area_filter, prob_filter)

            # 满足上面两条要求的RCNN预测边界框坐标
            class_objects = tf.boolean_mask(class_objects, object_filter)
            # 满足要求的RCNN预测边界框针对该类别的概率
            class_prob = tf.boolean_mask(class_prob, object_filter)

            # We have to use the TensorFlow's bounding box convention to use
            # the included function for NMS.
            class_objects_tf = change_order(class_objects)

            # Apply class NMS.
            # NMS后得到保留的边界框的索引, 此时保留的也就是该类别下最终保留的
            # 保留下来的数量是一定的, 由self._class_max_detections(Maximum number
            # of detections for each class.)确定
            class_selected_idx = tf.image.non_max_suppression(
                class_objects_tf, class_prob, self._class_max_detections,
                iou_threshold=self._class_nms_threshold
            )

            # Using NMS resulting indices, gather values from Tensors.
            class_objects_tf = tf.gather(class_objects_tf, class_selected_idx)
            class_prob = tf.gather(class_prob, class_selected_idx)

            # Revert to our bbox convention.
            class_objects = change_order(class_objects_tf)

            # We append values to a regular list which will later be
            # transformed to a proper Tensor.
            # 这里选定的是该类别下, 经过"边界剪裁(不会删除边界框), 对于该类别预测概率限定+坐
            # 标合理性限定+NMS(都会删除边界框)"处理后剩下的预测框的原图坐标和对应的预测概率
            selected_boxes.append(class_objects)
            selected_probs.append(class_prob)
            # In the case of the class_id, since it is a loop on classes, we
            # already have a fixed class_id. We use `tf.tile` to create that
            # Tensor with the total number of indices returned by the NMS.
            # 这里利用tile重复张量[class_id]了tf.shape(class_selected_idx)[0]次,
            # 生成了与剩下来的边界框的数量相同的长度的张量, 对应着selected_probs, 表述其中
            # 的边界框对应的类别
            selected_labels.append(
                tf.tile([class_id], [tf.shape(class_selected_idx)[0]])
            )

        # We use concat (axis=0) to generate a Tensor where the rows are
        # stacked on top of each other
        # selected_boxes ([num_classes, num_pred_after_nms, 4])
        objects = tf.concat(selected_boxes, axis=0)
        # selected_labels ([num_classes, num_pred_after_nms, 1])
        proposal_label = tf.concat(selected_labels, axis=0)
        # selected_probs ([num_classes, num_pred_after_nms, 1])
        proposal_label_prob = tf.concat(selected_probs, axis=0)

        tf.summary.histogram(
            'proposal_cls_scores', proposal_label_prob, ['rcnn']
        )

        # Get top-k detections of all classes.
        k = tf.minimum(
            self._total_max_detections,
            tf.shape(proposal_label_prob)[0]
        )
        # 获得所有框的所有类别的预测概率中, 前k个最大的结果, 概率, 坐标, 类别标签
        top_k = tf.nn.top_k(proposal_label_prob, k=k)
        top_k_proposal_label_prob = top_k.values
        top_k_objects = tf.gather(objects, top_k.indices)
        top_k_proposal_label = tf.gather(proposal_label, top_k.indices)

        return {
            'objects'            : top_k_objects,
            'proposal_label'     : top_k_proposal_label,
            'proposal_label_prob': top_k_proposal_label_prob,
            'selected_boxes'     : selected_boxes,
            'selected_probs'     : selected_probs,
            'selected_labels'    : selected_labels,
        }
